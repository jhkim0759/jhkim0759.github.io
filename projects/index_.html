<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="description"
        content="Efficient Artistic Mesh Generation via Component Decoupling.">
  <meta name="keywords" content="FastMesh, Artistic Mesh, Mesh Generation">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>FastMesh: Efficient Artistic Mesh Generation via Component Decoupling</title>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <link href="https://fonts.googleapis.com/css?family=Google+Sans|Noto+Sans|Castoro" rel="stylesheet">

    <link rel="stylesheet" href="./static/css/bulma.min.css">
    <link rel="stylesheet" href="./static/css/bulma-carousel.min.css">
    <link rel="stylesheet" href="./static/css/bulma-slider.min.css">
    <link rel="stylesheet" href="./static/css/fontawesome.all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
    <link rel="stylesheet" href="./static/css/index.css">

    <style>
       
        .results-carousel {
            display: flex;
            flex-wrap: wrap;         
            justify-content: center; 
            align-items: flex-start; 
            gap: 20px;              
           
            
          }
          .caption-text {
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .render_wrapper {
                position: relative;
                height: 300px;
                
                
            }
      
        .render_div {
          position: absolute;
          top: 0;
          left: 0;
        }

       
       
    </style>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script defer src="./static/js/fontawesome.all.min.js"></script>
    <script src="./static/js/bulma-carousel.min.js"></script>
    <script src="./static/js/bulma-slider.min.js"></script>
    <script src="./static/js/index.js"></script>
    <!-- model viewer -->
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.1.1/model-viewer.min.js"></script>
</head>
<body>

<section class="hero">
  <div class="hero-body">
    <div class="container is-max-desktop">
      <div class="columns is-centered">
        <div class="column has-text-centered">
          <h1 class="title is-1 publication-title">FastMesh: Efficient Artistic Mesh Generation via Component Decoupling</h1>
          <div class="is-size-5 publication-authors">
            <span class="author-block">
              <a href="https://jhkim0759.github.io/">Jeonghwan Kim</a>,</span>
            <span class="author-block">
              <a href="https://nirvanalan.github.io/">Yushi Lan</a>,</span>
            <span class="author-block">
              <a href="https://atfortes.github.io/">Armando Fortes</a>,
            </span>
            <span class="author-block">
              <a href="https://cyw-3d.github.io/">Yongwei Chen</a>,
            </span>
            <span class="author-block">
              <a href="https://xingangpan.github.io/">Xingang Pan</a>,
            </span>
          </div>

          <div class="is-size-5 publication-authors">
            <span class="author-block">S-Lab, Nanyang Technological University</span>
          </div>

        <div class="column has-text-centered">
            <div class="publication-links">
              <!-- PDF Link. -->
              <span class="link-block">
                <a href="https://arxiv.org/pdf/2508.19188"
                   class="external-link button is-normal is-rounded is-dark">
                  <span class="icon">
                      <i class="fas fa-file-pdf"></i>
                  </span>
                  <span>Paper</span>
                </a>
              </span>
              <span class="link-block">
                <a href="https://arxiv.org/abs/2508.19188"
                   class="external-link button is-normal is-rounded is-dark">
                  <span class="icon">
                      <i class="ai ai-arxiv"></i>
                  </span>
                  <span>arXiv</span>
                </a>
              </span>
              <!-- Video Link. -->
              <!-- Code Link. -->
              <span class="link-block">
                <a href="https://github.com/jhkim0759/FastMesh"
                   class="external-link button is-normal is-rounded is-dark">
                  <span class="icon">
                      <i class="fab fa-github"></i>
                  </span>
                  <span>Code</span>
                  </a>
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<section class="hero teaser">
  <div class="container is-max-desktop">
    <div class="hero-body">
      <video id="teaser" autoplay muted loop playsinline height="100%">
        <source src="./static/videos/Teaser.mp4"
                type="video/mp4">
      </video>
      <h2 class="subtitle has-text-centered">
        <b>FastMesh</b> generates high-quality artistic meshes from input shape conditions.
      </h2>
    </div>
  </div>
</section>

<section class="section">
  <div class="container is-max-desktop">
    <!-- Abstract. -->
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Abstract</h2>
        <div class="content has-text-justified">
          <p>
            Recent mesh generation approaches typically tokenize triangle meshes into sequences of tokens and train autoregressive models to generate these tokens sequentially. 
            Despite substantial progress, such token sequences inevitably reuse vertices multiple times to fully represent manifold meshes, as each vertex is shared by multiple faces. 
            This redundancy leads to excessively long token sequences and inefficient generation processes. In this paper, we propose an efficient framework that generates artistic meshes by treating vertices and faces separately, significantly reducing redundancy. 
            We employ an autoregressive model solely for vertex generation, decreasing the token count to approximately 23% of that required by the most compact existing tokenizer. 
            Next, we leverage a bidirectional transformer to complete the mesh in a single step by capturing inter-vertex relationships and constructing the adjacency matrix that defines the mesh faces. 
            To further improve the generation quality, we introduce a fidelity enhancer to refine vertex positioning into more natural arrangements and propose a post-processing framework to remove undesirable edge connections. 
            Experimental results show that our method achieves more than 8× faster speed on mesh generation compared to state-of-the-art approaches, while producing higher mesh quality.
          </p>
        </div>
      </div>
    </div>
    <!--/ Abstract. -->     
  <div class="container is-max-desktop">
    <!-- Pipeline. -->
    <div class="columns is-centered has-text-centered">
      <div class="column is-full-widt">
        <h2 class="title is-3">Method</h2>
        <div class="content has-text-justified">
          <p>
            <b>FastMesh</b> generate mesh components—vertices and faces—sequentially to avoid duplication issues commonly encountered in mesh tokenization.
            For vertex generation, we employ an autoregressive model, as it inherently accommodates varying vertex counts.
          </p>
          <video id="vertgen" autoplay muted loop playsinline height="100%">
          <source src="./static/videos/vertgen.mp4"
                  type="video/mp4">
          </video>
          <p>
            For face generation, we leverage a bidirectional transformer to model the relationships between vertices, from which edge connections can be directly derived in one step.
          </p>
          <video id="facegen" autoplay muted loop playsinline height="1%">
          <source src="./static/videos/facegen.mp4"
                  type="video/mp4">
          </video>
          
        </div>
      </div>
    </div>
</section>



 <section class="hero is-light is-small">
        <div>
            <h2 class="title is-3" style="text-align: center;"> Point-cloud Conditioned Mesh Generation </h2>
            <div class="container", id="render-container">
                <p style="text-align: center;">
                    FastMesh creates the mesh on the right from the point cloud on the left. 
                    Drag with the left mouse button to change the view, right mouse button to move the mesh.
                </p>
                <div id="results-carousel" class=" carousel results-carousel ">
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_001" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_cond_001" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_002" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_cond_002" class="render_div"></div>
                    </div>
                </div>
                <div id="results-carousel" class=" carousel results-carousel ">
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_003" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_cond_003" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_004" class="render_div"></div>
                    </div>
                    <div class=" item item-steve render_wrapper">
                        <div id="pc_cond_004" class="render_div"></div>
                    </div>
                </div>
    
            </div>
        </div>
        
    </section>

<script>
        window.addEventListener("DOMContentLoaded", function() {
          var video = document.getElementById("teaser");
          video.playbackRate = 0.8; 
        });
      </script>


<section class="section" id="BibTeX">
  <div class="container is-max-desktop content">
    <h2 class="title">BibTeX</h2>
    <pre><code>@misc{kim2025fastmesh,
      title={FastMesh: Efficient Artistic Mesh Generation via Component Decoupling}, 
      author={Jeonghwan Kim and Yushi Lan and Armando Fortes and Yongwei Chen and Xingang Pan},
      year={2025},
      eprint={2508.19188},
      archivePrefix={arXiv},
      url={https://arxiv.org/abs/2508.19188}, 
}</code></pre>
  </div>
</section>


<footer class="footer">
  <div class="container">
    <div class="content has-text-centered">
      <a class="icon-link"
         href="https://arxiv.org/pdf/2508.19188">
        <i class="fas fa-file-pdf"></i>
      </a>
      <a class="icon-link" href="https://github.com/jhkim0759/FastMesh" class="external-link" disabled>
        <i class="fab fa-github"></i>
      </a>
    </div>
    <div class="columns is-centered">
      <div class="column is-8">
        <div class="content">
          <p>
            This website is built using the source code provided by the <a href="https://github.com/nerfies/nerfies.github.io">Nerfies</a> and <a href="https://zhaorw02.github.io/DeepMesh/">DeepMesh</a>. 
          </p>
        </div>
      </div>
    </div>
  </div>
</footer>


<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "./js/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

    import { PLYLoader } from './js/PLYLoader.js';
    import { OrbitControls } from './js/OrbitControls.js';
    import { GLTFLoader } from './js/GLTFLoader.js';
    


    let div_to_scene = {};
    

    let items = [
        "001",
        "002",
        "003",
        "004",
        "005",
        "006",
        "007",
        "008",
        "009",
        "010",
        "011",
        "012",
        "013",
        "014",
        "015",
        "016",
        "017",
        "018",
        "019",
        "020"
       
        

    ]
   
    let currentPage = 1;  
    let itemsPerPage = 4; 
    let totalPages = Math.ceil(items.length / itemsPerPage) || 1; 

    for (let item of items) {
        let key = `images_${item}`;
        div_to_scene[key] = { geo: null, color: null };
        key = `pc_cond_${item}`;
        div_to_scene[key] = { geo: null, color: null };
        key = `pc_${item}`;
        div_to_scene[key] = { geo: null, color: null };
    }



    let mouse_button_down = false;
    let list_of_orbit_controls = []
    let style_camera = null;
    let render_colors = true;
    let style_id = "0"

    function setup_camera(div_name){
        console.log(div_name)
        let container = document.getElementById(div_name);
        let width = container.parentElement.clientWidth;
        let height = container.parentElement.clientHeight;
        let camera = new THREE.PerspectiveCamera( 52, width / height, 0.1, 50 );

        
        
        //let camera_init_position = new THREE.Vector3( 2.25, 1.525, -3.75 );
        let camera_init_position = new THREE.Vector3( 2.25, 1.525, 3.75 );
        
        
        camera_init_position = camera_init_position.multiplyScalar(0.5)
        camera.position.set(camera_init_position.x, camera_init_position.y, camera_init_position.z);
        return camera;
    }
    

    function setup_render_divs(div_name, mesh_path){
        let camera = setup_camera(div_name)
        let orbit_control = create_render_div(camera, div_name, mesh_path)
        list_of_orbit_controls.push(orbit_control)
    }

    function setup_render_divs_pc(div_name, mesh_path){
        let camera = setup_camera(div_name)
        let orbit_control = create_point_cloud_div(camera, div_name, mesh_path)
        list_of_orbit_controls.push(orbit_control)
    }

    function clear_scenes() {
        for (let div_id in div_to_scene) {
            let container = document.getElementById(div_id);
            if (container) {
                container.innerHTML = ''; 
            }
        }
        list_of_orbit_controls = []; 
    }
    
    function render_page(page) {
        clear_scenes(); 
        let startIdx = (page - 1) * itemsPerPage; 
        let endIdx = Math.min(startIdx + itemsPerPage, items.length);
    
        for (let i = 0; i < itemsPerPage; i++) {
            let itemIdx = startIdx + i;
            if (itemIdx >= items.length) break; 
            console.log(i)
            let item = items[itemIdx];
            let pcDiv = `pc_00${i + 1}`;
            let pcCondDiv = `pc_cond_00${i + 1}`;
    
            setup_render_divs_pc(pcDiv, `./models/pc/${item}.ply`);
            setup_render_divs(pcCondDiv, `./models/pc_cond_ply/${item}.ply`);
            
        }
    }

    function nextPage() {
        if (currentPage < totalPages) {
            currentPage++;
            render_page(currentPage);
        }
    }

    function prevPage() {
        if (currentPage > 1) {
            currentPage--;
            render_page(currentPage);
        }
    }
    
    window.onload = function () {
        render_page(currentPage); // 初始渲染第一页
    
        
        let renderContainer = document.getElementById("render-container");
    
      
        let navContainer = document.createElement("div");
    
        navContainer.style.display = "flex";
        navContainer.style.justifyContent = "center";
        navContainer.style.gap = "50px";
        navContainer.style.marginTop = "20px";
       
        navContainer.style.padding = "10px 0";
        //navContainer.style.background = "rgba(255, 255, 255, 0.9)";
        navContainer.style.borderRadius = "8px";
    
        function styleButton(button) {
            button.style.padding = "10px 20px";
            button.style.border = "none";
            button.style.backgroundColor = "#a641c6";
            button.style.color = "white";
            button.style.fontSize = "16px";
            button.style.borderRadius = "5px";
            button.style.cursor = "pointer";
            button.style.transition = "background 0.3s, transform 0.2s";
            button.onmouseover = () => (button.style.backgroundColor = "#68297c");
            button.onmouseout = () => (button.style.backgroundColor = "#a641c6");
            button.onmousedown = () => (button.style.transform = "scale(0.95)");
            button.onmouseup = () => (button.style.transform = "scale(1)");
        }
    
        let prevButton = document.createElement("button");
        prevButton.textContent = "Back";
        prevButton.onclick = prevPage;
        styleButton(prevButton);
    
        let nextButton = document.createElement("button");
        nextButton.textContent = "Next";
        nextButton.onclick = nextPage;
        styleButton(nextButton);
    

    
    
        function updateButtons() {
            prevButton.style.display = currentPage === 1 ? "none" : "block";
            nextButton.style.display = currentPage === totalPages ? "none" : "block";
        }
        
        /*function updateButtons() {
            if (currentPage === 0) {
                prevButton.style.display = "none"; 
            } else {
                prevButton.style.display = "block";
            }

            if (currentPage === totalPages - 1) {
                nextButton.style.display = "none"; 
            } else {
                nextButton.style.display = "block";
            }
        }*/
    
       
        navContainer.appendChild(prevButton);
        //navContainer.appendChild(pageIndicator);
        navContainer.appendChild(nextButton);
    
      
        if (renderContainer) {
            renderContainer.appendChild(navContainer);
            //updatePageIndicator(); // 首次加载时创建指示器
        }
    };


    function create_point_cloud_div(camera, div_id, point_cloud_path) {
        let container;
        let renderer, controls;
    
        init();
        animate();
    
        function init() {
            container = document.getElementById(div_id);
            let width = container.parentElement.clientWidth;
            let height = container.parentElement.clientHeight;
    
            div_to_scene[div_id]["color"] = new THREE.Scene();
            div_to_scene[div_id]["geo"] = new THREE.Scene();
            div_to_scene[div_id]["color"].background = new THREE.Color( 0xffffff );
            div_to_scene[div_id]["geo"].background = new THREE.Color( 0xffffff );

            // PLY file
            const loader = new PLYLoader();
            loader.load( point_cloud_path, function ( geometry ) {
                
                
                const material = new THREE.PointsMaterial({ color: 0x3e2984, size: 0.01 });

                
                const points = new THREE.Points(geometry, material);
                const points2 = new THREE.Points(geometry, material);

                div_to_scene[div_id]["geo"].add( points );
                div_to_scene[div_id]["color"].add( points2 );

            }, (xhr) => {
                console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
            }, (error) => {
                console.log('load fail')
                console.log(error)
            }
            );
    
            div_to_scene[div_id]["color"].add( new THREE.HemisphereLight( 0x333333, 0x222222 ) );
            div_to_scene[div_id]["geo"].add( new THREE.HemisphereLight( 0x333333, 0x222222 ) );
            addShadowedLight(div_to_scene[div_id]["color"], 1, 1, 1, 0xffffff, 1.35 / 2 );
            addShadowedLight(div_to_scene[div_id]["color"],  0.5, 1, - 1, 0xffffff, 1 / 2 );
            addShadowedLight(div_to_scene[div_id]["geo"], 1, 1, 1, 0xffffff, 1.35 );
            addShadowedLight(div_to_scene[div_id]["geo"],  0.5, 1, - 1, 0xffffff, 1 );
    
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);
            renderer.outputEncoding = THREE.sRGBEncoding;
    
            renderer.shadowMap.enabled = true;
    
            container.appendChild(renderer.domElement);
    
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = false;
    
            // Resize
            window.addEventListener('resize', onWindowResize);
        }
    
        function onWindowResize() {
            let width = container.clientWidth;
            let height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize( width, height );
        }
        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            renderer.render( div_to_scene[div_id][render_colors ? "color" : "geo"], camera );
            controls.update();
        }

        return controls;
    }

   

    function create_render_div(camera, div_id, mesh_path) {
        let container;
        let renderer, controls;

        init();
        animate();

        function init() {

            container = document.getElementById(div_id);
            let width = container.parentElement.clientWidth;
            let height = container.parentElement.clientHeight;

            div_to_scene[div_id]["color"] = new THREE.Scene();
            div_to_scene[div_id]["geo"] = new THREE.Scene();
            div_to_scene[div_id]["color"].background = new THREE.Color( 0xffffff );
            div_to_scene[div_id]["geo"].background = new THREE.Color( 0xffffff );

            // PLY file
            // console.log(mesh_path)
            const loader = new PLYLoader();
            loader.load( mesh_path, function ( geometry ) {
              
                geometry.computeVertexNormals();
                    
                let start_color = new THREE.Color(0.416, 0.106, 0.604); // 紫色
                let end_color = new THREE.Color(1.0, 0.976, 0.769);     // 黄色

              
                let position = geometry.attributes.position;
                let minY = Infinity, maxY = -Infinity;
                for (let i = 0; i < position.count; i++) {
                    let y = position.getY(i);
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                }
                let deltaY = maxY - minY || 1; 
                
                let colors = new Float32Array(position.count * 3);
                for (let i = 0; i < position.count; i++) {
                    let t = (position.getY(i) - minY) / deltaY; 
                    let color = new THREE.Color(
                        start_color.r * (1 - t) + end_color.r * t,
                        start_color.g * (1 - t) + end_color.g * t,
                        start_color.b * (1 - t) + end_color.b * t
                    );
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }

               
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                let material_color = new THREE.MeshStandardMaterial({
                    vertexColors: true, 
                    flatShading: true,
                    side: THREE.DoubleSide
                });
                let material_geo = new THREE.MeshStandardMaterial({
                    vertexColors: true, // 启用顶点颜色
                    flatShading: true,
                    side: THREE.DoubleSide
                });

                // let material_color = new THREE.MeshStandardMaterial( { color: 0x4169E1, flatShading: true, side: THREE.DoubleSide } )
                //let material_geo = new THREE.MeshStandardMaterial( { color: 0x2e4e8c, flatShading: true, side: THREE.DoubleSide } )

                let wireframe = new THREE.WireframeGeometry( geometry );
                let line = new THREE.LineSegments( wireframe );
                
                line.material.color.setHex(0x000000);
       
                
               

                const mesh_color = new THREE.Mesh( geometry, material_color );
                const mesh_geo = new THREE.Mesh( geometry, material_geo );

                div_to_scene[div_id]["color"].add( mesh_color );
                div_to_scene[div_id]["color"].add(line);
                div_to_scene[div_id]["geo"].add( mesh_geo );

            }, (xhr) => {
                console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
            }, (error) => {
                console.log('load fail')
                console.log(error)
            }
            );

            // lights

            //div_to_scene[div_id]["color"].add( new THREE.HemisphereLight( 0x333333, 0x222222 ) );
            //div_to_scene[div_id]["geo"].add( new THREE.HemisphereLight( 0x333333, 0x222222 ) );

            /*addShadowedLight(div_to_scene[div_id]["color"], 1, 1, 1, 0xffffff, 1.35 / 2 );
            addShadowedLight(div_to_scene[div_id]["color"],  0.5, 1, - 1, 0xffffff, 1 / 2 );
            addShadowedLight(div_to_scene[div_id]["geo"], 1, 1, 1, 0xffffff, 1.35 );
            addShadowedLight(div_to_scene[div_id]["geo"],  0.5, 1, - 1, 0xffffff, 1 );*/
            // 1. 添加环境光（均匀照亮所有面）
            let ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            div_to_scene[div_id]["color"].add(ambientLight);
            div_to_scene[div_id]["geo"].add(ambientLight.clone());

            // 2. 添加半球光（让整体光照更自然）
            let hemiLight = new THREE.HemisphereLight(0xffffff, 0x888888, 0.6);
            hemiLight.position.set(0, 10, 0);
            div_to_scene[div_id]["color"].add(hemiLight);
            div_to_scene[div_id]["geo"].add(hemiLight.clone());
            

            // renderer

            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( width, height);
            renderer.outputEncoding = THREE.sRGBEncoding;

            renderer.shadowMap.enabled = true;

            container.appendChild( renderer.domElement );

            controls = new OrbitControls(camera, renderer.domElement)
            controls.enableDamping = false

            // resize

            window.addEventListener( 'resize', onWindowResize );

    }
        function onWindowResize() {
            let width = container.clientWidth;
            let height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize( width, height );
        }
        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            renderer.render( div_to_scene[div_id][render_colors ? "color" : "geo"], camera );
            controls.update();
        }

        return controls;
    }


    function addShadowedLight(scene, x, y, z, color, intensity ) {
    

    }

    document.addEventListener('keydown', logKey);

    function logKey(evt) {
        if (evt.keyCode === 71 && !mouse_button_down) {
            switch_geometry()
        }
        if (evt.keyCode === 82 && !mouse_button_down) {
            list_of_orbit_controls.forEach(oc => {
                console.log(oc.object.position)
            })
            reset_orbit_controls()
        }
    }

    function switch_geometry() {
        render_colors = !render_colors
    }

    function reset_orbit_controls() {
        list_of_orbit_controls.forEach(oc => {
            oc.reset()
        })
    }

    function set_style_0(){
        style_id = "0"
    }

    function set_style_1(){
        style_id = "1"
    }

    function set_style_2(){
        style_id = "2"
    }

    document.body.onmousedown = function(evt) {
        if (evt.button === 0)
            mouse_button_down = true
    }
    document.body.onmouseup = function(evt) {
        if (evt.button === 0)
            mouse_button_down = false
    }

    

    </script>

    

</body>

</html>
